package com.athtech;

import java.util.*;

/**
 * This class implements a state of the "Family crossing the bridge" problem.
 *
 * @author Vasilis Papadimitrakopoulos
 */
public class StateNode implements Iterable<StateNode> {

    /**
     * The minimum bridge capacity.
     */
    private static final int MIN_BRIDGE_CAPACITY = 1;

    /**
     * The maximum bridge capacity.
     */
    private final int MAX_BRIDGE_CAPACITY = 2;

    /**
     * The torch.
     */
    private static Torch torch = new Torch();

    /**
     * The Family Members.
     */
    private static final Grandpa grandpa = new Grandpa();
    private static final Father father = new Father();
    private static final Mother mother = new Mother();
    private static final Sister sister = new Sister();
    private static final Brother brother = new Brother();

    /**
     * The amount of family members at the source bank.
     */
    private final List<FamilyMember> figuresAtSourceBank;

    /**
     * The amount of family members at the target bank.
     */
    private final List<FamilyMember> figuresAtTargetBank;


    /**
     * Constructs a state.
     *
     * @param figuresAtSourceBank amount of figures at source bank.
     * @param figuresAtTargetBank amount of figures at target bank.
     * @param torch               the torch.
     */
    public StateNode(List<FamilyMember> figuresAtSourceBank, List<FamilyMember> figuresAtTargetBank, Torch torch) {
        this.figuresAtSourceBank = figuresAtSourceBank;
        this.figuresAtTargetBank = figuresAtTargetBank;
        this.torch = torch;
    }

    /**
     * Creates the source state node.
     *
     * @return the initial state node.
     */
    public static StateNode getInitialStateNode() {

        List figuresAtSourceBank = Arrays.asList(grandpa, father, mother, sister, brother);
        List figuresAtTargetBank = new ArrayList();
        torch.setLocation(TorchLocation.SOURCE_BANK);

        return new StateNode(figuresAtSourceBank,
                figuresAtTargetBank,
                torch);
    }

    /**
     * Checks whether this state encodes a solution state, in which all figures
     * are at the target bank.
     *
     * @return {@code true} if this state is a solution state.
     */
    public boolean isSolutionState() {
        return torch.getLocation() == TorchLocation.TARGET_BANK
                && torch.getBatteryLife() >= 0
                && figuresAtTargetBank.size() == 5
                && figuresAtSourceBank.size() == 0;
    }

    /**
     * Checks whether this state is terminal, which is the case whenever the torch
     * runs out of battery
     *
     * @return {@code true} if this state is terminal.
     */
    public boolean isTerminalState() {
        return torch.getBatteryLife() < 0;
    }

    /**
     * Returns an iterator over this state's neighbor states.
     *
     * @return an iterator.
     */
    @Override
    public Iterator<StateNode> iterator() {
        return new NeighborStateIterator();
    }

    /**
     * {@inheritDoc }
     */
    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder();

        int missionaryFieldLength = ("" + totalMissionaries).length();
        int cannibalFieldLength = ("" + totalCannibals).length();

        // Situation at the source bank.
        sb.append(String.format("[m: %" + missionaryFieldLength + "d",
                missionaries));
        sb.append(String.format(", c: %" + cannibalFieldLength + "d]",
                cannibals));

        // Draw boat location.
        switch (boatLocation) {
            case SOURCE_BANK: {
                sb.append("v ~~~  ");
                break;
            }

            case TARGET_BANK: {
                sb.append("  ~~~ v");
                break;
            }
        }

        // Situation at the destination bank.
        sb.append(String.format("[m: %" + missionaryFieldLength + "d",
                totalMissionaries - missionaries));
        sb.append(String.format(", c: %" + cannibalFieldLength + "d]",
                totalCannibals - cannibals));
        return sb.toString();
    }

    /**
     * {@inheritDoc }
     */
    @Override
    public boolean equals(Object o) {
        if (!(o instanceof StateNode)) {
            return false;
        }

        StateNode other = (StateNode) o;
        return missionaries == other.missionaries
                && cannibals == other.cannibals
                && totalMissionaries == other.totalMissionaries
                && totalCannibals == other.totalCannibals
                && boatLocation == other.boatLocation;
    }

    /**
     * {@inheritDoc }
     */
    @Override
    public int hashCode() {
        // Generated by NetBeans.
        int hash = 7;
        hash = 31 * hash + this.missionaries;
        hash = 31 * hash + this.cannibals;
        hash = 31 * hash + this.totalMissionaries;
        hash = 31 * hash + this.totalCannibals;
        hash = 31 * hash + Objects.hashCode(this.boatLocation);
        return hash;
    }

    // Implements the actual iterator.
    private class NeighborStateIterator implements Iterator<StateNode> {

        private final Iterator<StateNode> iterator;

        public NeighborStateIterator() {
            this.iterator = generateNeighbors();
        }

        @Override
        public boolean hasNext() {
            return iterator.hasNext();
        }

        @Override
        public StateNode next() {
            return iterator.next();
        }

        // Populates the list of neighbor states.
        private Iterator<StateNode> generateNeighbors() {
            if (isTerminalState()) {
                // Ignore terminal state nodes.
                return Collections.<StateNode>emptyIterator();
            }

            List<StateNode> list = new ArrayList<>();

            switch (StateNode.this.boatLocation) {
                case SOURCE_BANK: {
                    trySendFromSourceBank(list);
                    break;
                }

                case TARGET_BANK: {
                    trySendFromTargetBank(list);
                    break;
                }
            }

            return list.iterator();
        }

        // Attempts to send some figures from the source bank to the target
        // bank.
        private void trySendFromSourceBank(List<StateNode> list) {
            int availableMissionaries = Math.min(missionaries, boatCapacity);
            int availableCannibals = Math.min(cannibals, boatCapacity);

            for (int capacity = 1; capacity <= boatCapacity; ++capacity) {
                for (int m = 0; m <= availableMissionaries; ++m) {
                    for (int c = 0; c <= availableCannibals; ++c) {
                        if (0 < c + m && c + m <= capacity) {
                            list.add(new StateNode(missionaries - m,
                                    cannibals - c,
                                    totalMissionaries,
                                    totalCannibals,
                                    boatCapacity,
                                    BoatLocation.TARGET_BANK));
                        }
                    }
                }
            }
        }

        // Attempts to send some figures from the target bank to the source
        // bank.
        private void trySendFromTargetBank(List<StateNode> list) {
            int availableMissionaries =
                    Math.min(totalMissionaries - missionaries, boatCapacity);
            int availableCannibals =
                    Math.min(totalCannibals - cannibals, boatCapacity);

            for (int capacity = 1; capacity <= boatCapacity; ++capacity) {
                for (int m = 0; m <= availableMissionaries; ++m) {
                    for (int c = 0; c <= availableCannibals; ++c) {
                        if (0 < c + m && c + m <= capacity) {
                            list.add(new StateNode(missionaries + m,
                                    cannibals + c,
                                    totalMissionaries,
                                    totalCannibals,
                                    boatCapacity,
                                    BoatLocation.SOURCE_BANK));
                        }
                    }
                }
            }
        }
    }


    /**
     * Checks that missionary count is in order.
     *
     * @param missionaries      the amount of missionaries at the source bank.
     * @param totalMissionaries total amount of missionaries in the game.
     */
    private static void checkMissionaryCount(int missionaries,
                                             int totalMissionaries) {
        checkNotNegative(missionaries,
                "Negative amount of missionaries: " + missionaries);
        checkIntNotLess(totalMissionaries,
                missionaries,
                "Missionaries at a bank (" + missionaries + "), " +
                        "missionaries in total (" + totalMissionaries + ").");
    }

    /**
     * Checks that cannibal count is in order.
     *
     * @param cannibals      the amount of cannibals at the source bank.
     * @param totalCannibals total amount of cannibals in the game.
     */
    private static void checkCannibalCount(int cannibals,
                                           int totalCannibals) {
        checkNotNegative(cannibals,
                "Negative amount of cannibals: " + cannibals);
        checkIntNotLess(totalCannibals,
                cannibals,
                "Cannibals at a bank (" + cannibals + "), " +
                        "cannibals in total (" + totalCannibals + ").");
    }


    /**
     * Checks that {@code integer} is no less than {@code minimum}, and if it
     * is, throws an exception with message {@code errorMessage}.
     *
     * @param integer      the integer to check.
     * @param minimum      the minimum allowed value of {@code integer}.
     * @param errorMessage the error message.
     * @throws IllegalArgumentException if {@code integer < minimum}.
     */
    private static void checkIntNotLess(int integer,
                                        int minimum,
                                        String errorMessage) {
        if (integer < minimum) {
            throw new IllegalArgumentException(errorMessage);
        }
    }

    /**
     * Checks that {@code integer} is not negative.
     *
     * @param integer      the integer to check.
     * @param errorMessage the error message for the exception upon failure.
     */
    private static void checkNotNegative(int integer, String errorMessage) {
        checkIntNotLess(integer, 0, errorMessage);
    }
}